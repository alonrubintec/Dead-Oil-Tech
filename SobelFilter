// Simple post-process Sobel Filter shader.
// Samples depth, normals, and color differences around each pixel to compute edge strength 'g'.
// Then blends the outline color based on that edge strength.
//
// 4-point sampling explanation:
//   uv0 = top-left
//   uv1 = bottom-right
//   uv2 = top-right
//   uv3 = bottom-left
// These diagonal offsets let the shader measure how much depth, normal,
// or color changes in different directions. Large differences = strong edges.

TEXTURE2D_X(_BlitTexture);
SAMPLER(sampler_BlitTexture);

float Linear01Depth(float z)
{
    const float isOrtho = unity_OrthoParams.w;
    const float isPers = 1.0 - unity_OrthoParams.w;
    z *= _ZBufferParams.x;
    return (1.0 - isOrtho * z) / (isPers * z + _ZBufferParams.y);
}

float SampleDepth(float2 uv)
{
    const float d = SampleSceneDepth(uv);
    return Linear01Depth(d);
}

float4 SampleCameraColor(float2 uv)
{
    return SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_BlitTexture, UnityStereoTransformScreenSpaceTex(uv));
}

// New function to compute edge strength 'g' at a given UV
float ComputeG(float2 uv)
{
    const float offset_positive = +ceil(_EdgeThickness * 0.5f);
    const float offset_negative = -floor(_EdgeThickness * 0.5f);

    #if RESOLUTION_INVARIANT_THICKNESS
        const float screen_ratio = _ScreenSizeData.x / _ScreenSizeData.y;
        const float2 texel_size = 1.0 / 800.0 * float2(1.0, screen_ratio);
    #else
        const float2 texel_size = _ScreenSizeData.zw;
    #endif

    const float left = texel_size.x * offset_negative;
    const float right = texel_size.x * offset_positive;
    const float top = texel_size.y * offset_negative;
    const float bottom = texel_size.y * offset_positive;

    const float2 uv0 = uv + float2(left, top);
    const float2 uv1 = uv + float2(right, bottom);
    const float2 uv2 = uv + float2(right, top);
    const float2 uv3 = uv + float2(left, bottom);

    #ifdef OUTLINE_USE_DEPTH
        const float d0 = SampleDepth(uv0);
        const float d1 = SampleDepth(uv1);
        const float d2 = SampleDepth(uv2);
        const float d3 = SampleDepth(uv3);
        const float depth_threshold_scale = 300.0f;
        float d = length(float2(d1 - d0, d3 - d2)) * depth_threshold_scale;
        d = smoothstep(_DepthMin, _DepthMax, d);
    #else
        float d = 0.0f;
    #endif

    #ifdef OUTLINE_USE_NORMALS
        const float3 n0 = SampleSceneNormals(uv0);
        const float3 n1 = SampleSceneNormals(uv1);
        const float3 n2 = SampleSceneNormals(uv2);
        const float3 n3 = SampleSceneNormals(uv3);
        const float3 nd1 = n1 - n0;
        const float3 nd2 = n3 - n2;
        float n = sqrt(dot(nd1, nd1) + dot(nd2, nd2));
        n = smoothstep(_NormalMin, _NormalMax, n);
    #else
        float n = 0.0f;
    #endif

    #ifdef OUTLINE_USE_COLOR
        const float3 c0 = SampleCameraColor(uv0).rgb;
        const float3 c1 = SampleCameraColor(uv1).rgb;
        const float3 c2 = SampleCameraColor(uv2).rgb;
        const float3 c3 = SampleCameraColor(uv3).rgb;
        const float3 cd1 = c1 - c0;
        const float3 cd2 = c3 - c2;
        float c = sqrt(dot(cd1, cd1) + dot(cd2, cd2));
        c = smoothstep(_ColorMin, _ColorMax, c);
    #else
        float c = 0.0f;
    #endif

    return max(d, max(n, c));
}

void Outline_float(float2 UV, out float4 Out)
{
    float4 original = SampleCameraColor(UV);

    #if RESOLUTION_INVARIANT_THICKNESS
        const float screen_ratio = _ScreenSizeData.x / _ScreenSizeData.y;
        const float2 texel_size = 1.0 / 800.0 * float2(1.0, screen_ratio);
    #else
        const float2 texel_size = _ScreenSizeData.zw;
    #endif

    // Compute 'g' at original UV and an offset UV, then average for anti-aliasing
    const float g1 = ComputeG(UV);
    const float g2 = ComputeG(UV + 0.5 * texel_size);
    const float g = (g1 + g2) / 2.0;

    #ifdef OUTLINE_FADE_OUT
        const float linear_depth = LinearEyeDepth(SampleSceneDepth(UV), _ZBufferParams);
        const float fade = smoothstep(_FadeRangeEnd, _FadeRangeStart, linear_depth);
        _OutlineColor.a *= fade;
    #endif

    #ifdef OUTLINE_ONLY
        original.rgb = lerp(1.0 - _OutlineColor.rgb, _OutlineColor.rgb, g * _OutlineColor.a);
    #endif

    float4 output;
    output.rgb = lerp(original.rgb, _OutlineColor.rgb, g * _OutlineColor.a);
    output.a = original.a;

    Out = output;
}
