using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// DrillHierarchyManager
/// ----------------------------------
/// Lightweight hierarchy manager for drills or branching objects.
/// Fully supports recursive relationships and behavior propagation.
///
/// Features:
/// 1. Tracks parent, children, and all ancestors.
/// 2. Supports recursive stepping:
///    - **Upwards:** check parent, grandparent, uncles, etc.
///    - **Downwards:** traverse children, grandchildren, nieces/nephews.
/// 3. Methods to query hierarchy for any state recursively.
/// 4. Safe removal with optional descendant cleanup.
/// 5. Can be used to propagate visual/material/behavior changes across hierarchy.
/// </summary>

public class DrillHierarchyManager : MonoBehaviour
{
    [Header("Hierarchy References")]
    public DrillHierarchyManager parent;          // Immediate parent
    public List<DrillHierarchyManager> children = new List<DrillHierarchyManager>(); // Direct children

    [Header("Optional Ancestor Tracking")]
    public List<DrillHierarchyManager> ancestors = new List<DrillHierarchyManager>(); // All ancestors up to root

    public void InitializeHierarchy(DrillHierarchyManager newParent)
    {
        parent = newParent;

        if (parent != null && !parent.children.Contains(this))
            parent.children.Add(this);

        // Update ancestors recursively
        ancestors.Clear();
        DrillHierarchyManager current = parent;
        while (current != null)
        {
            ancestors.Add(current);
            current = current.parent;
        }
    }

    public List<DrillHierarchyManager> GetAllDescendants()
    {
        List<DrillHierarchyManager> result = new List<DrillHierarchyManager>();
        foreach (var child in children)
        {
            result.Add(child);
            result.AddRange(child.GetAllDescendants()); // Recursive step
        }
        return result;
    }

    public bool AnyAncestor(System.Predicate<DrillHierarchyManager> predicate)
    {
        foreach (var anc in ancestors)
        {
            if (predicate(anc))
                return true;
        }
        return false;
    }

    public List<DrillHierarchyManager> GetSiblings()
    {
        if (parent == null) return new List<DrillHierarchyManager>();

        List<DrillHierarchyManager> siblings = new List<DrillHierarchyManager>(parent.children);
        siblings.Remove(this);
        return siblings;
    }

    public List<DrillHierarchyManager> GetUncles()
    {
        if (parent == null) return new List<DrillHierarchyManager>();
        return parent.GetSiblings();
    }

    public bool AnyDescendant(System.Predicate<DrillHierarchyManager> predicate)
    {
        foreach (var child in children)
        {
            if (predicate(child) || child.AnyDescendant(predicate))
                return true; // Recursive step
        }
        return false;
    }

    public void ApplyToSelfAndDescendants(System.Action<DrillHierarchyManager> action)
    {
        action?.Invoke(this);
        foreach (var child in children)
        {
            child.ApplyToSelfAndDescendants(action); // Recursive step
        }
    }

    public void RemoveFromHierarchy(bool destroyDescendants = false)
    {
        if (parent != null)
            parent.children.Remove(this);

        if (destroyDescendants)
        {
            foreach (var child in children)
            {
                child.RemoveFromHierarchy(true);
                Destroy(child.gameObject);
            }
        }

        children.Clear();
        ancestors.Clear();
        parent = null;
    }
}
